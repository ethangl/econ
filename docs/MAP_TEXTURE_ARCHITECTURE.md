# Map Texture Architecture

## Goal

Define a texture pipeline that is:

- easy to debug (no opaque channel packing tricks),
- scalable to many map modes,
- safe for runtime-generated maps,
- and maintainable as simulation data grows (politics, economy, climate, war, demographics).

This document is the target architecture and migration plan.

---

## Design Principles

1. **One semantic per channel whenever possible.**
   Avoid packed bitfields like `biome*8 + soil + waterFlag` unless there is no practical alternative.

2. **Separate static from dynamic data.**
   Static data resolves once after map generation; dynamic data updates incrementally per tick/day/event.

3. **Keep selection/hover on always-available core IDs.**
   Interaction must not depend on active map mode data bindings.

4. **Prefer deterministic preprocessing over heavy fragment logic.**
   Compute expensive conversions once (or at low frequency), then sample cheap textures in the render pass.

5. **Format choice is part of architecture.**
   Precision and quantization are first-class design decisions, not implementation details.

---

## Current Baseline (As Implemented)

Core data texture:

- `_CellDataTex` (`RGBAFloat`, gridWidth x gridHeight)
  - R: realmId / 65535
  - G: provinceId / 65535
  - B: packed biome/soil/water
  - A: countyId / 65535

Supporting textures include:

- heightmap (`RFloat`)
- river mask (`R8`)
- border distance maps (realm/province/county/market, `R8`)
- road mask (`R8`)
- palettes (realm/market/biome)
- biome-elevation matrix
- county-to-market lookup

Known pain points:

- packed B channel is fragile and hard to inspect,
- adding data requires either more packing or sampler pressure,
- shader complexity is high because domain decoding and rendering are coupled.

---

## Target Architecture (Hybrid Resolve Model)

Use a **hybrid pipeline**:

- **Always-bound core textures** for IDs and interaction.
- **Domain textures** with clear channels for gameplay data.
- **Resolved display texture** per active map mode (generated by resolve step).
- **Thin compositing shader** for final layering (terrain + mode color + water + selection/hover).

### Why this model

- Scales to many modes without fragment sampler explosion.
- Keeps map interaction stable and mode-independent.
- Lets us trade update frequency per domain (static, event-driven, per-day, per-frame).
- Matches runtime-generation constraints better than offline-only baking.

---

## Texture Classes

### A) Always-Bound Core (required every frame)

1. **Political IDs**

- Suggested format: `RGBA16` or `RGBAFloat` (keep float until integer texture path is added)
- Channels:
  - R: realmId
  - G: provinceId
  - B: countyId
  - A: reserved (barony/cell group/flags)

2. **Geography Base**

- Suggested format: `RGBA8` or `RGBA16`
- Channels:
  - R: biomeId
  - G: soilId
  - B: rockId / terrainClass
  - A: waterFlag (or coast class)

3. **Heightmap**

- Existing `RFloat` is acceptable.

4. **Hydrology Masks**

- river mask (`R8`)
- optional lake/ocean classification (`R8`) if needed separately from water flag.

5. **Core border distance maps**

- realm/province/county (market optional depending on mode needs).

### B) Domain Data (bound in resolve step, not always in fragment)

1. **Climate**

- temp, precipitation, moisture, seasonal modifier

2. **Economy**

- market zone, wealth, supply pressure, resource tier

3. **Demographics**

- population density, cultureId, religionId, development

4. **Military/Control**

- control, siege, fort level, attrition/supply line strength

5. **Diplomacy/State overlays**

- occupation, de jure/de facto divergence, treaty state masks

### C) Resolved Outputs

1. **Mode Color Resolve**

- `RGBA8`/`RGBA16` color texture generated for active map mode.

2. **Optional Mode Aux**

- mode-specific edge/heat/intensity map if a mode needs additional post effects.

---

## Data Format Guidance

Use this policy until profiling forces a change:

- **IDs**: store with enough precision for stable equality checks.
  - Current normalized float IDs are acceptable with strict encode/decode discipline.
  - Long term: prefer integer formats/samplers where backend support is reliable.

- **Continuous values** (temp/moisture/wealth): `UNorm8` or `UNorm16` depending on visible banding risk.

- **Masks and flags**: `R8` unless multiple masks are naturally co-located.

- **Never repack unrelated semantics into one channel** for convenience.

---

## Render Pipeline

### Stage 1: Map Build (once per generation/load)

Generate:

- core ID textures,
- geography textures,
- height/hydrology,
- static border distance maps,
- static domain textures.

### Stage 2: Resolve (on mode switch and on relevant data changes)

Resolve pass reads only required textures for that mode and writes:

- `ModeColorResolve`.

Mode switch cost is a one-time resolve, not sustained per-frame branching complexity.

### Stage 3: Composite (every frame)

Final shader samples:

- terrain inputs (height/geography/water),
- `ModeColorResolve`,
- core IDs for selection/hover,
- border/road masks as needed.

This pass should be simple and stable.

---

## Shader Organization

Keep one material/shader if desired, but modularize source:

- `MapOverlay.Common.cginc` (sampling, ID decode, constants),
- `MapOverlay.ResolveModes.cginc` (mode-specific resolve logic),
- `MapOverlay.Composite.cginc` (final compositing, hover/selection/water).

Avoid a single giant function for all concerns.

---

## Performance Strategy

1. **First optimize architecture, then micro-optimize shader math.**
2. **Resolve at the lowest valid frequency**:
   - static modes: once,
   - economy/diplomacy: event-driven or daily,
   - highly dynamic overlays: per-frame only if required.
3. **Profile texture fetch count in composite pass** and keep it bounded.
4. **Do not rely on sampler-limit assumptions alone**; verify on target backend.

---

## Render Detail Height + Normal Pipeline

Add a dedicated visual-relief path that is separate from gameplay elevation.

### Intent

- **Gameplay height** remains authoritative for simulation systems.
- **Render height** exists only for visual detail and lighting.

This prevents visual tuning from accidentally changing economics, routing, or terrain logic.

### Outputs

1. **Render Heightmap** (`R16` or `RFloat`)

- Derived from gameplay height + deterministic detail synthesis.
- Used for hillshading detail and optional visual displacement/parallax.

2. **Render Normal Map** (`RGBA8`/normal-encoded)

- Derived from Render Heightmap.
- Used by terrain shading for high-frequency relief.

### Generation Stage

Generate both textures in **Stage 1 (Map Build)** after base height/hydrology are available.
Default cadence is **once per map generation/load**, not per frame.

### Synthesis Recipe (deterministic)

Start from normalized gameplay height and apply:

1. **Low-pass smoothing**

- gentle Gaussian blur to remove hard cell transitions.

2. **Macro variation**

- low-frequency noise/ridge modulation to break up broad flats.

3. **Micro variation**

- 2-3 octaves of subtle detail noise for terrain texture.

4. **Hydrology-aware masking**

- reduce high-frequency detail near rivers/lakes to avoid noisy banks.

5. **Slope-aware attenuation**

- clamp detail on steep cliffs to prevent faceted glittering artifacts.

Use deterministic seed derivation from map seed + explicit `renderReliefSeedOffset`.

### Suggested Parameters

- `reliefBlurRadius`: 2-5 texels
- `macroAmplitude`: 0.02-0.08 of normalized height range
- `microAmplitude`: 0.01-0.04
- `microOctaves`: 2-3
- `normalStrength`: 0.4-1.2

All values should be exposed as generation config, not serialized runtime tweak state.

### Guardrails

1. Never feed Render Heightmap into gameplay systems.
2. Never overwrite or reinterpret gameplay height values from visual textures.
3. Keep visual detail bounded to preserve coastline and river readability.
4. Verify deterministic output for fixed seed + parameters.

### Caching

Cache Render Heightmap + Render Normal Map with map save artifacts.
On reload, skip regeneration when cache key matches:

- map seed,
- map dimensions,
- relief parameter set,
- generator version.

---

## Debug and Validation Requirements

Add permanent debug tooling:

1. **Channel Inspector Mode**

- render any texture/channel directly to screen with numeric min/max in UI.

2. **ID Probe**

- click cell and display decoded values from all core/domain textures.

3. **Golden Map Regression**

- fixed seed maps with expected checksum/stat snapshots for texture generation.

4. **Color Stability Tests**

- verify hover/border operations preserve hue class for low-saturation colors.

5. **Relief Validation**

- side-by-side debug view for gameplay height vs render height.
- normal map visualization mode.
- checksum regression for render height + normal outputs.

These tools are mandatory before adding large new data domains.
These validation gates are tracked as required completion criteria for Milestone M3 (`M3-S4`) in the backlog.
Execution checklist: `M3_TEXTURE_REGRESSION_CHECKLIST.md`.

Status snapshot (February 10, 2026):

- EditMode automated validation for `M3-S4` is in place and passing for fixed-seed texture determinism, mode/economy refresh behavior, and low-saturation hover/border color stability.
- Remaining signoff items are manual Channel Inspector + ID Probe validation across baseline cases and direct `ModeColorResolve` invalidation assertions once the resolved texture path is enabled.

---

## Migration Plan

### Phase 1: Cleanup and Safety (now)

1. Remove packed biome/soil/water channel in favor of explicit geography channels.
2. Keep current rendering behavior equivalent.
3. Add channel inspector and ID probe.

### Phase 2: Core Texture Split

1. Split monolithic cell data into:
   - Political IDs texture
   - Geography base texture
2. Update selection/hover to consume only political IDs.
3. Keep existing map modes functional.

### Phase 3: Resolve Pipeline

1. Introduce `ModeColorResolve`.
2. Move map-mode color derivation into resolve step.
3. Simplify composite shader to layering only.
4. Implement resolve invalidation rules: rerun resolve on mode switch and relevant domain-data changes.

### Phase 4: Domain Expansion

Prerequisite: Phase 3 regression/validation gates are passing.

1. Add climate/economy/demographic/military textures with explicit schemas.
2. Bind only required domain textures in resolve per mode.
3. Add mode-level update scheduling (event/day/frame).

### Phase 5: Optional Advanced Path

1. Evaluate integer texture path for IDs.
2. Evaluate texture arrays only if binding churn becomes measurable.
3. Add disk caching for resolved textures alongside saved maps.

### Milestone Mapping (Backlog Alignment)

1. `M3-S1` covers Phase 1 and Phase 2 baseline migration goals.
2. `M3-S2` supports Phase 3 by modularizing shader responsibilities while preserving behavior parity.
3. `M3-S3` delivers Phase 3 resolve behavior, including invalidation triggers.
4. `M3-S4` enforces regression + validation gates before any Phase 4 domain expansion.

---

## Non-Goals

- Not targeting mobile constraints right now.
- Not replacing runtime generation with offline editor bake workflows.
- Not splitting into many materials per mode unless profiling proves required.

---

## Decision Summary

- **Chosen direction:** Hybrid resolve architecture.
- **Immediate action:** Eliminate packed channels and add debug tooling.
- **Medium-term action:** Resolve-per-mode pipeline with thin composite shader.
- **Long-term action:** Expand domains safely with explicit schemas and update cadence rules.

This approach keeps interaction robust, avoids fragile encoding, and scales to CK3-class map data without turning the fragment shader into a permanent bottleneck.
